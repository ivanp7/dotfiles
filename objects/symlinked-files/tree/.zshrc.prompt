# prompt

# source git-prompt.sh
. /usr/share/git/completion/git-prompt.sh

############################################################################

_p_bold="%B"
_p_stopbold="%b"

_p_color()
{
    echo "%F{$1}$([ -n "$2" ] && echo "%K{$2}" || true)"
}

_p_safe_color()
{
    if [ $(tput colors) -gt 8 ]; then echo "$1"; else echo "$2"; fi
}

_p_color_white=${_p_bold}$(_p_color 7)

_p_stdcolor=$(_p_safe_color "$(_p_color 244)" "$(_p_color 7)${_p_stopbold}")%k
_p_cmdcolor=${_p_color_white}

_p_dash="─"
_p_2dash="═"
_p_arrow="→"
_p_top="┌"
_p_mid="╞"
_p_bot="└"
_p_mid_r="┐"
_p_bot_r="┘"

############################################################################

_p_timeinfo()
{
    local TimeInfoColor=${_p_color_white}
    echo "${_p_dash}[${TimeInfoColor}%D{%T}${_p_stdcolor}]"
}

_p_cmdtimeinfo()
{
    local CmdTimeInfoColor=${_p_color_white}
    echo "${_p_dash}[${CmdTimeInfoColor}${_p_timer_delta}s${_p_stdcolor}]"
}

_p_cmdstatusinfo()
{
    local SuccessColor=${_p_bold}$(_p_color 2)
    local FailureColor=${_p_bold}$(_p_color 1)
    if [ $_p_exitcode -eq 0 ]
    then
        echo "${_p_dash}[${SuccessColor}ok${_p_stdcolor}]"
    else
        echo "${_p_dash}[${FailureColor}error ${_p_exitcode}${_p_stdcolor}]"
    fi
}

_p_processinfo()
{
    local OutputStr="$(sed "
        s/systemd//;
        s/---login//;
        s/---pstree//;
        s/---sh//g;
        s/---dash//g;
        s/---bash//g;
        s/---zsh//g;
        s/^---//;
        s/sshd---sshd/ssh/;
        s/tmux: server/tmux/;
        s/screen---screen/screen/;
        s/y-desktop.sh---screen---yaft/yaft/;
        s/---/]${_p_arrow}[/g; 
    " <<< $(pstree -ls $$))"

    [ -z "$OutputStr" ] && exit

    local TimeInfoLength=11
    local CmdTimeInfoLength=$((4 + ${#_p_timer_delta}))
    local CmdStatusLength=$((3 + $(
        if [ $_p_exitcode -ne 0 ]
        then echo $((6 + ${#_p_exitcode}))
        else echo 2
        fi)
    ))

    local PromptLength=$((2 + $TimeInfoLength + $CmdTimeInfoLength + $CmdStatusLength + 2))
    local MaxOutputLength=$(($_p_termwidth - $PromptLength))

    local PNameColor=${_p_color_white}
    local GapColor=$(_p_color 1)

    local SeparatorL="]${_p_arrow}"
    local ColSeparatorL="${_p_stdcolor}]${_p_arrow}"
    local SeparatorR="${_p_arrow}["
    local ColSeparatorR="${_p_arrow}[$PNameColor"

    if [ ${#OutputStr} -le $MaxOutputLength ]
    then
        local HalfColoredOutputStr=${OutputStr//$SeparatorL/$ColSeparatorL}
        local ColoredOutputStr=${HalfColoredOutputStr//$SeparatorR/$ColSeparatorR}
        echo "[$PNameColor$ColoredOutputStr${_p_stdcolor}]"
    else
        local OutputStrExcessLength=$((3 + ${#OutputStr} - $MaxOutputLength - 1))
        local OutputStrShort=${OutputStr:$OutputStrExcessLength}
        local HalfColoredOutputStrShort=${OutputStrShort//$SeparatorL/$ColSeparatorL}
        local ColoredOutputStrShort=${HalfColoredOutputStrShort//$SeparatorR/$ColSeparatorR}
        echo "$GapColor...${_p_stdcolor}$ColoredOutputStrShort${_p_stdcolor}]"
    fi
}

############################################################################

_p_username()
{
    if [ "$(id -u)" -eq 0 ]
    then
        local RootColor=${_p_bold}$(_p_color 7 1)
        echo "${RootColor}root${_p_stdcolor}"
    else
        local username_line="$(grep "^$USER " $HOME/.zshrc.prompt.usernames 2> /dev/null)"
        if [ "$(tput colors)" -ge 256 ] && [ -n "$username_line" ]
        then
            echo "$username_line" | read _ username
            echo "${username}${_p_stdcolor}"
        else
            local UserColor=$(_p_color 2)
            echo "${UserColor}${USER}${_p_stdcolor}"
        fi
    fi
}

_p_userhostinfo()
{
    local HostColor=$(_p_safe_color "$(_p_color 39)" "${_p_bold}$(_p_color 4)")
    echo "${_p_2dash}[$(_p_username)@${HostColor}$HOST${_p_stdcolor}]"
}

_p_gitinfo()
{
    local BranchColor=$(_p_safe_color "$(_p_color 165)" "${_p_bold}$(_p_color 5)")
    local ChangedBranchColor=$(_p_safe_color "$(_p_color 16 165)" "${_p_bold}$(_p_color 7 5)")
    if [ -z "${_p_gitbranch}" ]
    then
        echo "${_p_2dash}[${BranchColor}-${_p_stdcolor}]"

    elif [ -z "$_p_gitstatus" ]
    then
        echo "${_p_2dash}[${BranchColor}${_p_gitbranch}${_p_stdcolor}]"

    else
        echo "${_p_2dash}[${ChangedBranchColor}${_p_gitbranch}${_p_stdcolor}]"
    fi
}

_p_pwdinfo()
{
    local UsernameLength=$(if [ "$(id -u)" -eq 0 ]; then echo "4"; else echo "${#USER}"; fi)
    local UserHostInfoLength=$((4 + $UsernameLength + ${#HOST}))
    local GitInfoLength=$((3 + $(
        if [ -n "${_p_gitbranch}" ]
        then echo "${#_p_gitbranch}"
        else echo "1"
        fi)
    ))

    local PromptLength=$((1 + $UserHostInfoLength + $GitInfoLength + 3))
    local MaxOutputLength=$(($_p_termwidth - $PromptLength))
    local SeparatorLineLength=$(($MaxOutputLength - ${#PWD}))
    if [ $SeparatorLineLength -gt 2 ]
    then SeparatorLine="$(printf "%0.s${_p_dash}" $(seq 1 $(($SeparatorLineLength - 2))))${_p_mid_r} "
    else SeparatorLine="${_p_mid_r} "
    fi

    local DirColor=${_p_color_white}
    local SlashColor=${_p_stdcolor}
    local GapColor=$(_p_color 1)

    if [ $SeparatorLineLength -ge 2 ]
    then

        local ColPWD=$DirColor${PWD//\//$SlashColor\/$DirColor}
        echo "${_p_2dash}[$ColPWD${_p_stdcolor}]${SeparatorLine}"
    else
        local PWDExcessLength=$((3 + ${#PWD} - $MaxOutputLength + 2))
        local PWD1=${PWD:0:(${#PWD} / 2 - ($PWDExcessLength + 1) / 2)}
        local ColPWD1=$DirColor${PWD1//\//$SlashColor\/$DirColor}
        local PWD2=${PWD:(${#PWD} / 2 + $PWDExcessLength / 2)}
        local ColPWD2=$DirColor${PWD2//\//$SlashColor\/$DirColor}

        echo "${_p_2dash}[$ColPWD1$GapColor...$ColPWD2${_p_stdcolor}]${SeparatorLine}"
    fi
}

############################################################################

function zle-keymap-select {
    CommandModeIndicatorColor=$(_p_color 7 1)
    RPROMPT="${_p_stdcolor}[$([ "$KEYMAP" = "vicmd" ] && 
        echo "${CommandModeIndicatorColor} <<< COMMAND >>> ")${_p_stdcolor}]${_p_dash}${_p_bot_r}"
    RPROMPT2=$RPROMPT
    zle reset-prompt
}
zle -N zle-keymap-select

function zle-line-finish {
    RPROMPT="${_p_stdcolor}[${_p_color_white}%D{%T}${_p_stdcolor}]${_p_dash}${_p_bot_r}"
    RPROMPT2=$RPROMPT
    zle reset-prompt
}
zle -N zle-line-finish

# Fix a bug when you C-c in CMD mode and you'd be prompted with CMD mode indicator, while in fact you would be in INS mode
# Fixed by catching SIGINT (C-c), set vim_mode to INS and then repropagate the SIGINT, so if anything else depends on it, we will not break it
function TRAPINT() {
    SIGINTColor=$(_p_color 1)
    RPROMPT="${_p_stdcolor}[${SIGINTColor}SIGINT${_p_stdcolor}]${_p_dash}${_p_bot_r}"
    RPROMPT2=$RPROMPT
    zle reset-prompt
    return $(( 128 + $1 ))
} 

_p_character()
{
    if [ "$(id -u)" -ne 0 ]; then echo "$"; else echo "#"; fi
}

############################################################################

_p_timer_start ()
{
    _p_timer=${_p_timer:-$SECONDS}
}

_p_timer_delta=0

_p_command ()
{
    _p_exitcode="$?" # This needs to be first

    if [ -n "$_p_timer" ]
    then
        _p_timer_delta=$(($SECONDS - $_p_timer))
        [ $_p_timer_delta -lt 0 ] && _p_timer_delta=0
        unset _p_timer
    fi

    _p_termwidth=$(tput cols)

    _p_gitbranch="$(__git_ps1 '%s')"
    _p_gitstatus=$([ -n "$(git status --short 2> /dev/null)" ] && echo "changed")

    ### Prompt ###

    local PromptLine1="${_p_stdcolor}${_p_top}$(_p_timeinfo)$(_p_cmdtimeinfo)$(_p_cmdstatusinfo) $(_p_processinfo)"
    local PromptLine2="${_p_stdcolor}${_p_mid}$(_p_userhostinfo)$(_p_gitinfo)$(_p_pwdinfo)"
    local PromptLine3="${_p_stdcolor}${_p_bot}${_p_dash}"

    print -P "${_p_stdcolor}"
    print -P "$PromptLine1"
    print -P "$PromptLine2"
    PROMPT="$PromptLine3 $(_p_character) ${_p_cmdcolor}"

    PROMPT2="$PromptLine3 > ${_p_cmdcolor}"

    RPROMPT="${_p_stdcolor}[]${_p_dash}${_p_bot_r}"
    RPROMPT2=$RPROMPT
}

add-zsh-hook preexec _p_timer_start
add-zsh-hook precmd _p_command

# vim: set ft=sh:

