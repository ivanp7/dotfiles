" #############################################################################
" General settings

set nocompatible

set background  =dark

set expandtab             " Use spaces instead of tabs.
set tabstop     =4        " Tab key indents by 4 spaces.
set softtabstop =4        " Tab key indents by 4 spaces.
set shiftwidth  =4        " >> indents by 4 spaces.
set shiftround            " >> indents to next multiple of 'shiftwidth'.

set hidden                " Switch between buffers without having to save first.
set laststatus  =2        " Always show statusline.
set display     =lastline " Show as much as possible of the last line.
set number
set relativenumber
set scroll      =10

" set showmode              " Show current mode in command-line.
set noshowmode
set showcmd               " Show already typed keys when more are expected.

set ttyfast               " Faster redrawing.
set lazyredraw            " Only redraw when necessary.

set splitbelow            " Open new windows below the current window.
set splitright            " Open new windows right of the current window.

set cursorline            " Find the current line quickly.
set wrapscan              " Searches wrap around end-of-file.
set report      =0        " Always report changed lines.
set synmaxcol   =400      " Only highlight the first 400 columns.
" set colorcolumn =80

set hlsearch

set mouse       =a

if has("mouse_sgr")
    set ttymouse=sgr
else
    set ttymouse=xterm2
end

set autoread

let g:matchparen_timeout = 50
let g:matchparen_insert_timeout = 50

" let &colorcolumn="80,82,84,86,88,".join(range(90,400),",")
let &colorcolumn="80,90,100"

set clipboard^=unnamedplus

set list                   " Show non-printable characters.
if has('multi_byte') && &encoding ==# 'utf-8'
  let &listchars = 'tab:▸ ,extends:❯,precedes:❮,nbsp:±'
else
  let &listchars = 'tab:> ,extends:>,precedes:<,nbsp:.'
endif

set keymap=russian-jcukenwin
set iminsert=0
set imsearch=0
set spelllang=ru_yo,en_us

set timeoutlen=3000

" 256-colors support
set t_Co=256

" No error sound&visual bells
set belloff=all

" Put all temporary files under the same directory.
" https://github.com/mhinz/vim-galore#handling-backup-swap-undo-and-viminfo-files
set backup
set backupdir   =$HOME/.vim/files/backup/
set backupext   =-vimbackup
set backupskip  =
set directory   =$HOME/.vim/files/swap/
set updatecount =100
set undofile
set undodir     =$HOME/.vim/files/undo/
set viminfo     ='100,n$HOME/.vim/files/info/viminfo

" #############################################################################
" Plug.vim plugin system

" Autoload plug.vim
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

" Specify a directory for plugins
call plug#begin('~/.vim/plugged')

" Basic things
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-repeat'
Plug 'farmergreg/vim-lastplace'
Plug 'tpope/vim-obsession'
Plug 'tpope/vim-tbone'

Plug 'tpope/vim-surround'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-capslock'

Plug 'tpope/vim-eunuch'
Plug 'majutsushi/tagbar'
Plug 'ptzz/lf.vim'
Plug 'rbgrouleff/bclose.vim'
Plug 'qpkorr/vim-bufkill'

Plug 'christoomey/vim-tmux-navigator'

" Fixes for things
Plug 'godlygeek/csapprox'
Plug 'powerman/vim-plugin-AnsiEsc'
" Plug 'tmux-plugins/vim-tmux-focus-events'

" Color theme and highlighting
Plug 'jaxbot/semantic-highlight.vim'

Plug 'itchyny/lightline.vim'
Plug 'edkolev/tmuxline.vim'
Plug 'smancill/darkglass'
Plug 'raymond-w-ko/vim-niji'
Plug 'Yggdroot/indentLine'

Plug 'guns/xterm-color-table.vim'

Plug 'inkarkat/vim-ingo-library'
Plug 'inkarkat/vim-mark'

" Tmux conf
Plug 'tmux-plugins/vim-tmux'

" S-expressions and Lisp
Plug 'guns/vim-sexp'
Plug 'tpope/vim-sexp-mappings-for-regular-people'

Plug 'l04m33/vlime', {'rtp': 'vim/'}

" Initialize plugin system
call plug#end()

" #############################################################################
" Basic things

" Vim Commentary **********************

autocmd FileType lisp setlocal commentstring=;\ %s

" lf.vim **************************

let g:lf_replace_netrw = 1 " open lf when vim open a directory

" Tagbar ******************************

nmap <F8> :TagbarToggle<CR>

" Vim-tmux navigator

" Disable tmux navigator when zooming the Vim pane
"
let g:tmux_navigator_disable_when_zoomed = 1

" #############################################################################
" Fixes for things

" CSApprox ****************************

" Enable true color 启用终端24位色
if exists('+termguicolors') && ($TERM != 'linux') && ($TERM != 'yaft-256color')
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
      set termguicolors
      endif

" tweak color scheme
let g:CSApprox_hook_post = [
            \ 'highlight CursorLine        guibg=#444444 cterm=NONE ctermbg=234',
            \ 'highlight CursorLineNR      guifg=#ee3333 cterm=bold ctermfg=red',
            \ 'highlight LineNr            guifg=#999999 ctermfg=gray',
            \ 'highlight MatchParen        guifg=#ffffff guibg=#ff0000 ctermbg=1',
            \ 'highlight ColorColumn       guibg=#111111 ctermbg=232',
            \]

" #############################################################################
" Color theme and highlighting

" Semantic highlight
"
let g:semanticEnableFileTypes = ['c', 'cpp', 'java', 'javascript', 'python', 'vim']
let g:semanticTermColors = range(1, 14)

" Vim-lightline

function! LanguageStatus(...) abort
    return &iminsert == 1 ? (a:0 == 1 ? a:1 : 'RU') : ''
endfunction

function! CapsLockStatus(...) abort
    return CapsLockStatusline('CAPS')
endfunction

let g:lightline = {
      \ 'colorscheme': 'powerline',
      \ 'active': {
      \   'left': [ [ 'mode', 'lang', 'caps', 'paste' ],
      \             [ 'gitbranch', 'filename', 'readonly', 'modified' ] ]
      \ },
      \ 'component_function': {
      \   'lang': 'LanguageStatus',
      \   'caps': 'CapsLockStatus',
      \   'gitbranch': 'fugitive#head'
      \ },
      \ }

" Vim color scheme ********************

colorscheme darkglass

" indentLine **************************

let g:indentLine_color_gui = '#888888'
let g:indentLine_color_term = 242

" Vim-mark ****************************

let g:mwHistAdd = ''

nmap <Plug>IgnoreMarkSearchNext <Plug>MarkSearchNext
nmap <Plug>IgnoreMarkSearchPrev <Plug>MarkSearchPrev

nmap * <Plug>MarkSearchGroupNext
nmap # <Plug>MarkSearchGroupPrev

nmap <Leader>1  <Plug>MarkSearchGroup1Next
nmap <Leader>!  <Plug>MarkSearchGroup1Prev

" #############################################################################
" S-expressions and Lisp

" Vim-Sexp ****************************

let g:sexp_insert_after_wrap = 0

let g:sexp_mappings = {
            \ 'sexp_flow_to_prev_open':         'g?(',
            \ 'sexp_flow_to_next_close':        'g/)',
            \ 'sexp_flow_to_prev_close':        'g?)',
            \ 'sexp_flow_to_next_open':         'g/(',
            \ 'sexp_flow_to_prev_leaf_head':    'gH',
            \ 'sexp_flow_to_next_leaf_head':    'gh',
            \ 'sexp_flow_to_prev_leaf_tail':    'gL',
            \ 'sexp_flow_to_next_leaf_tail':    'gl',
            \
            \ 'sexp_round_head_wrap_list':      '<LocalLeader>ei',
            \ 'sexp_round_tail_wrap_list':      '<LocalLeader>eI',
            \ 'sexp_round_head_wrap_element':   '<LocalLeader>ew',
            \ 'sexp_round_tail_wrap_element':   '<LocalLeader>eW',
            \ 'sexp_splice_list':               '<LocalLeader>e@',
            \ 'sexp_convolute':                 '<LocalLeader>e?',
            \ 'sexp_raise_list':                '<LocalLeader>eo',
            \ 'sexp_raise_element':             '<LocalLeader>eO',
            \
            \ 'sexp_insert_at_list_head':       '<LocalLeader>eh',
            \ 'sexp_insert_at_list_tail':       '<LocalLeader>el',
            \
            \ 'sexp_square_head_wrap_list':     '<LocalLeader>e[',
            \ 'sexp_square_tail_wrap_list':     '<LocalLeader>e]',
            \ 'sexp_curly_head_wrap_list':      '<LocalLeader>e{',
            \ 'sexp_curly_tail_wrap_list':      '<LocalLeader>e}',
            \ 'sexp_square_head_wrap_element':  '<LocalLeader>ee[',
            \ 'sexp_square_tail_wrap_element':  '<LocalLeader>ee]',
            \ 'sexp_curly_head_wrap_element':   '<LocalLeader>ee{',
            \ 'sexp_curly_tail_wrap_element':   '<LocalLeader>ee}',
            \ }

" Vlime *******************************

let g:vlime_leader = '<LocalLeader>'
let g:vlime_enable_autodoc = v:true
let g:vlime_window_settings = 
      \ {'repl':      {'pos': 'belowright', 'vertical': v:true},
       \ 'sldb':      {'pos': 'belowright', 'vertical': v:true}, 
       \ 'inspector': {'pos': 'belowright', 'vertical': v:true}, 
       \ 'preview':   {'pos': 'belowright', 'size': v:null, 'vertical': v:true}}

let g:vlime_force_default_keys = v:true
" let g:vlime_cl_use_terminal = v:true

function! VlimeEnableInteractionMode()
    let b:vlime_interaction_mode = v:true
    nnoremap <buffer> <silent> <cr> :call vlime#plugin#SendToREPL(vlime#ui#CurExprOrAtom())<cr>
    vnoremap <buffer> <silent> <cr> :<c-u>call vlime#plugin#SendToREPL(vlime#ui#CurSelection())<cr>
endfunction

autocmd FileType lisp call VlimeEnableInteractionMode()
autocmd BufNewFile,BufRead * if &ft=~?'lisp'|:call VlimeEnableInteractionMode()|endif

let g:vlime_cl_impl = "ros"
function! VlimeBuildServerCommandFor_ros(vlime_loader, vlime_eval)
    return ["ros", "run",
                \ "--load", a:vlime_loader,
                \ "--eval", a:vlime_eval]
endfunction

" #############################################################################
" Custom key mappings

" Reload vimrc
map <F5> :source $MYVIMRC<CR>

" Record into register 'q', playback with 'Q'
nnoremap Q @q

noremap ,, ,
noremap ,; ,

let mapleader=","
let maplocalleader=" "

set cedit=\<C-Y>

" Paste mode toggle
autocmd VimEnter * set pastetoggle=<F2>

" Switch language
nnoremap <silent> <C-^> :let &iminsert = (&iminsert == 0 ? 1 : 0)<CR>
nnoremap <silent> <C-S> :let &iminsert = (&iminsert == 0 ? 1 : 0)<CR>
inoremap <silent> <C-S> <C-O>:let &iminsert = (&iminsert == 0 ? 1 : 0)<CR>

" ==============================
" movement mappings
" ==============================

" Map the cursor keys for precision scrolling by visual lines
imap <up> <C-O>gk
imap <down> <C-O>gj
nmap <up> gk
nmap <down> gj
vmap <up> gk
vmap <down> gj

" Emacs-style editing in insert mode and on the command-line: 
" start of line
noremap! <C-A>		<Home>
" back one character
noremap! <C-B>		<Left>
" delete character under cursor
noremap! <C-D>		<Del>
" end of line
noremap! <C-E>		<End>
" forward one character
noremap! <C-F>		<Right>

" ==============================
" copy-paste mappings
" ==============================

noremap Y y$

" black hole register operations
map <leader>d "_d
map <leader>D "_D
map <leader>x "_x
map <leader>X "_X
map <leader>c "_c
map <leader>C "_C
map <leader>s "_s
map <leader>S "_S

" ==============================
" indentation mappings
" ==============================

" Visual mode blockwise indent
vmap > >gv
vmap < <gv

" Ident the whole buffer
map <F7> mzgg=G`z

" ==============================
" search&replace mappings
" ==============================

" Escape special characters in a string for exact matching.
" This is useful to copying strings from the file to the search tool
" Based on this - http://peterodding.com/code/vim/profile/autoload/xolox/escape.vim
function! EscapeString (string)
  let string=a:string
  " Escape regex characters
  let string = escape(string, '^$.*\/~[]')
  " Escape the line endings
  let string = substitute(string, '\n', '\\n', 'g')
  return string
endfunction

" Get the current visual block for search and replaces
" This function passed the visual block through a string escape function
" Based on this - https://stackoverflow.com/questions/676600/vim-replace-selected-text/677918#677918
function! GetVisual() range
  " Save the current register and clipboard
  let reg_save = getreg('"')
  let regtype_save = getregtype('"')
  let cb_save = &clipboard
  set clipboard&

  " Put the current visual selection in the " register
  normal! ""gvy
  let selection = getreg('"')

  " Put the saved registers and clipboards back
  call setreg('"', reg_save, regtype_save)
  let &clipboard = cb_save

  "Escape any special characters in the selection
  let escaped_selection = EscapeString(selection)

  return escaped_selection
endfunction

vmap <leader>v <Esc>/<c-r>=GetVisual()<cr>
vmap <leader>z <Esc>:%s/<c-r>=GetVisual()<cr>//gc<left><left><left>
vmap <leader>Z <Esc>:%s/<c-r>=GetVisual()<cr>/<c-r>=GetVisual()<cr>/gc<left><left><left>

" ==============================
" user interface operations mappings
" ==============================

" Resize windows
nnoremap <silent> <C-W><C-H> :vert res -10<CR>
nnoremap <silent> <C-W><C-J> :res -5<CR>
nnoremap <silent> <C-W><C-K> :res +5<CR>
nnoremap <silent> <C-W><C-L> :vert res +10<CR>
" Switch between windows: nmap <silent> <C-hjkl> :wincmd hjkl<CR>

function! SwitchToNextBuffer(incr)
    let help_buffer = (&filetype == 'help')
    let current = bufnr("%")
    let last = bufnr("$")
    let new = current + a:incr
    while 1
        if new != 0 && bufexists(new) &&
           \ ((getbufvar(new, "&filetype") == 'help') == help_buffer)
            execute ":buffer ".new
            break
        else
            let new = new + a:incr
            if new < 1
                let new = last
            elseif new > last
                let new = 1
            endif
            if new == current
                break
            endif
        endif
    endwhile
endfunction

nnoremap <silent> gb :call SwitchToNextBuffer(1)<CR>
nnoremap <silent> gB :call SwitchToNextBuffer(-1)<CR>

" Copy text to/from the system clipboard
command! CCI let @" = @+
command! CCO let @+ = @" | let @* = @"

