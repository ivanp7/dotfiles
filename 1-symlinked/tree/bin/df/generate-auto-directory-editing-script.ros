#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (setf *load-verbose* nil *load-print* nil
        *compile-verbose* nil *compile-print* nil)
  (ros:ensure-asdf)
  #+quicklisp
  (ql:quickload '(:alexandria :split-sequence) :silent t))

(defmacro run (command &rest args)
  (alexandria:once-only (command)
    `(uiop:run-program ,command :ignore-error-status t :input :interactive
                       :output '(:string :stripped t) 
                       :error-output :interactive . ,args)))

(defmacro output (run-form)
  `(nth-value 0 ,run-form))

(defmacro exit-code (run-form)
  `(nth-value 2 ,run-form))

(defmacro in-directory (path &body body)
  (alexandria:with-gensyms (cwd)
    `(let ((,cwd (uiop:getcwd)))
       (uiop:chdir ,path)
       (let ((result (multiple-value-list (progn . ,body))))
         (uiop:chdir ,cwd)
         (values-list result)))))

(defun list-files (path &rest types)
  (in-directory path
    (let ((result 
            (delete 
              "." 
              (split-sequence:split-sequence
                #\Linefeed 
                (output (run `("find" "." 
                               . ,(nbutlast 
                                    (mapcan (lambda (k)
                                              (list "-type" 
                                                    (string-downcase 
                                                      (symbol-name k))
                                                    "-o"))
                                            types)))))
                :remove-empty-subseqs t)
              :test #'string= :count 1)))
      (map-into result (lambda (path) (subseq path 2)) result))))

(defun read-links-into-table (path links prefix table)
  (in-directory path
    (dolist (link links)
      (let* ((link-value (output (run `("readlink" ,link)))) 
             (short-link-value
               (namestring (uiop:enough-pathname link-value prefix))))
        (when (string/= link-value short-link-value)
          (push link (gethash short-link-value table)))))))

(defun generate-mkdir-command (dir)
  (concatenate 'string "mkdir -v \"./" dir "\""))

(defun generate-rmdir-command (dir)
  (concatenate 'string "rm -dv \"./" dir "\""))

(defun generate-remove-command (file)
  (concatenate 'string "rm -v \"./" file "\""))

(defun generate-copy-command (src dest)
  (concatenate 'string "cp -anTv \"./" src "\" \"./" dest "\""))

(defun generate-move-command (src dest)
  (concatenate 'string "mv -nTv \"./" src "\" \"./" dest "\""))

(defun generate-copy-move-commands (source destinations)
  (if (null destinations)
    (list (generate-remove-command source))
    (let ((origin-removed (null (member source destinations :test #'equal)))
          (destinations (remove source destinations :test #'equal :count 1)))
      (let ((commands (mapcar (alexandria:curry #'generate-copy-command source) 
                              (rest destinations))))
        (if origin-removed
          (let ((last-command (generate-move-command 
                                source (first destinations)))) 
            (if (null commands)
              (setf commands (list last-command))
              (setf (cdr (last commands)) (list last-command))))
          (push (generate-copy-command source (first destinations)) commands))
        commands))))

(defun print-script (commands)
  (format t "#!/bin/sh~%")
  (dolist (command commands)
    (format t "~A && ~%" command))
  (format t "true || { echo 'Error occured, aborting.'; exit 1; }~%"))

(defun main (&rest argv)
  (handler-case
      (if (/= 2 (length argv))
        (error "incorrect number of arguments provided")
        (let ((original-dirtree 
                (or (namestring (truename (nth 0 argv))) 
                    (error "no original directory tree path specified")))
              (mirror-dirtree 
                (or (namestring (truename (nth 1 argv)))
                    (error "no mirror directory tree path specified"))))
          (when (string= original-dirtree mirror-dirtree)
            (error "original and mirror directories are the same"))
          
          (let ((original-files (list-files original-dirtree :f :l))
                (mirror-links (list-files mirror-dirtree :l))
                (dirtree-change-table (make-hash-table :test 'equal))
                (original-directories (list-files original-dirtree :d))
                (mirror-directories (list-files mirror-dirtree :d)))
            (dolist (file original-files)
              (setf (gethash file dirtree-change-table) '()))
            (read-links-into-table mirror-dirtree mirror-links 
                                   original-dirtree dirtree-change-table)
            (let ((new-directories 
                    (sort (set-difference mirror-directories
                                          original-directories
                                          :test #'equal) #'< :key #'length))
                  (unused-directories 
                    (sort (set-difference original-directories
                                          mirror-directories
                                          :test #'equal) #'> :key #'length)))
              (print-script 
                (nconc 
                  (mapcar #'generate-mkdir-command new-directories)
                  (let (commands) 
                    (maphash (lambda (key value)
                               (setf commands
                                     (nconc (generate-copy-move-commands
                                              key value) commands)))
                             dirtree-change-table)
                    commands)
                  (mapcar #'generate-rmdir-command unused-directories)))))))
      (t (msg) (format *error-output* "Error: ~A~%" msg) 1)))

;;; vim: set ft=lisp lisp:
