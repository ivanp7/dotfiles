# interpreter for shell commands (needs to be POSIX compatible)
set shell zsh

# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-eu'

# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"

# leave some space at the top and the bottom of the screen
set scrolloff 10

set color256
set drawbox on
set tabstop 4

map zp set preview!
map z1 :set nopreview; set ratios 1
map z2 set ratios 1:2
map z3 set ratios 1:2:3
map z4 set ratios 1:2:3:5
map z5 set ratios 1:2:3:5:8

set relativenumber

# cmd recol %{{
#     w=$(tput cols)
#     if [ $w -le 80 ]; then
#         lf -remote "send $id set ratios 1:2"
#     elif [ $w -le 160 ]; then
#         lf -remote "send $id set ratios 1:2:3"
#     else
#         lf -remote "send $id set ratios 1:2:3:5"
#     fi
# }}

# use enter for shell commands
# map <enter> shell

# do nothing; interrupt input
map <esc> $true

# execute current file (must be executable)
map x !"$f"
map X &"$f"

# create directory
cmd mkdir %mkdir "$(echo "$@")"; lf -remote "send $id reload"
map [ push ::mkdir<space>

# touch
map tt %touch ${(f)fx}; lf -remote "send $id reload"
# create file
cmd touch %touch "$(echo "$@")"; lf -remote "send $id reload"
map ] push ::touch<space>

# edit files
map e $$EDITOR ${(f)fx}

# read link
map al %readlink "$f"

# display owner & group
map ao %stat -c %U:%G "$f"

# calculate used space
map au %du -ch ${(f)fx} | tail -n 1

# set permissions (a+-rwxXst)
map t+r %chmod +r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-r %chmod -r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+w %chmod +w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-w %chmod -w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+x %chmod +x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-x %chmod -x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+X %chmod +X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-X %chmod -X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+s %chmod +s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-s %chmod -s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+t %chmod +t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-t %chmod -t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"

# set permissions (u+-rwxXst)
map tu+r %chmod u+r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-r %chmod u-r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+w %chmod u+w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-w %chmod u-w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+x %chmod u+x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-x %chmod u-x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+X %chmod u+X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-X %chmod u-X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+s %chmod u+s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-s %chmod u-s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+t %chmod u+t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-t %chmod u-t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"

# set permissions (g+-rwxXst)
map tg+r %chmod g+r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-r %chmod g-r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+w %chmod g+w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-w %chmod g-w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+x %chmod g+x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-x %chmod g-x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+X %chmod g+X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-X %chmod g-X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+s %chmod g+s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-s %chmod g-s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+t %chmod g+t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-t %chmod g-t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"

# set permissions (o+-rwxXst)
map to+r %chmod o+r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-r %chmod o-r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+w %chmod o+w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-w %chmod o-w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+x %chmod o+x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-x %chmod o-x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+X %chmod o+X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-X %chmod o-X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+s %chmod o+s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-s %chmod o-s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+t %chmod o+t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-t %chmod o-t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"

# copy path
map Ypx $echo -n "$f" | xclip -i -selection clipboard
map Ydx $echo -n "$(dirname "$f")" | xclip -i -selection clipboard
map Ynx $echo -n "$(basename "$f")" | xclip -i -selection clipboard
map Ypt $tmux set-buffer -- "$f"
map Ydt $tmux set-buffer -- "$(dirname "$f")"
map Ynt $tmux set-buffer -- "$(basename "$f")"

# dedicated keys for file opener actions
map o &mimeopen "$f"
map O $mimeopen --ask "$f"

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
cmd open ${{
    set -f
    case "$f" in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2|*.tar.gz|*.tgz|*.tar.xz|*.txz|*.zip|*.rar|*.iso)
            mntdir="$f-archivemount"
            [ ! -d "$mntdir" ] && {
                mkdir -p "$mntdir"
                archivemount "$f" "$mntdir"
                echo "$mntdir" >> "/tmp/__lf_archivemount_$id"
            }
            lf -remote "send $id cd \"$mntdir\""
            lf -remote "send $id reload"
            ;;
        *)
            case $(file --mime-type "$f" -b) in
                text/*) $EDITOR ${(f)fx};;
                image/*) $VIEWER ${(f)fx} &;;
                application/pdf) $PDFVIEWER ${(f)fx} &;;
                *) for f in ${(f)fx}; do setsid $OPENER "$f" > /dev/null 2> /dev/null & done;;
            esac
    esac
}}

# glob select&unselect
map V push ::glob-select<space>
map U push ::glob-unselect<space>

cmd moveless_toggle %{{
    lf -remote "send $id toggle"
    lf -remote "send $id select \"$(echo "$f")\""
}}
cmd back_toggle %{{
    lf -remote "send $id toggle"
    lf -remote "send $id select \"$(echo "$f")\""
    lf -remote "send $id up"
}}
map <space> moveless_toggle
map b toggle
map B back_toggle

# define a custom 'rename' command without prompt for overwrite
# cmd rename %[ -e $1 ] && printf "file exists" || mv $f $1
# map r push :rename<space>

cmd bulk_rename !{{
    original_names_file=$(mktemp)
    changed_names_file=$(mktemp)
    for file in ${(f)fs}
    do 
        echo "$file" >> $original_names_file
        echo "$file" >> $changed_names_file
    done
    $EDITOR $changed_names_file

    NAME_FIX="s/'/'\\\\''/g; s/^/'/; s/\$/'/"
    sed -i "$NAME_FIX" $original_names_file
    sed -i "$NAME_FIX" $changed_names_file

    if [ "$(cat $original_names_file | wc -l)" -ne "$(cat $changed_names_file | wc -l)" ]
    then
        echo "Error: number of lines is not equal to the number of files."
    else
        commands_file=$(mktemp)
        paste -d" " $original_names_file $changed_names_file > $commands_file
        rm $original_names_file $changed_names_file
        sed -i 's/^/mv -vi -- /' $commands_file
        $EDITOR $commands_file

        for cmd in $(cat $commands_file)
        do $SHELL -c "$cmd; true"
        done
        rm $commands_file
    fi
}}

cmd smart_rename ${{
    if [ -z "$fs" ]
    then lf -remote "send $id rename"
    else lf -remote "send $id bulk_rename"
    fi

    lf -remote "send $id reload"
}}

map r smart_rename
map R %vidir ${(f)fs}; lf -remote "send $id reload"

cmd paste %{{
    mode=""
    files=""
    lf -remote 'load' | while read file
    do
        if [ -z "$mode" ]
        then mode="$file"
        elif [ -n "$file" ]
        then
            files="yes"

            if [ "$mode" = "copy" ]; then
                target_name="$(basename "$file")"
                if [ "$(dirname "$file")" = "$PWD" ]; then
                    if [ ! -d "$file" ] || [ -L "$file" ] || [ ! -e "$target_name.copy" ]; then
                        target_name="$target_name.copy"
                    fi
                fi

                cp --backup=numbered -aT "$file" "$target_name"
            elif [ "$mode" = "move" ]; then
                if [ "$(dirname "$file")" != "$PWD" ]; then
                    mv --backup=numbered -t . "$file"
                fi
            fi
        fi
    done

    if [ -z "$files" ]; then
        lf -remote "send $id echo no files to paste"
        exit 0
    elif [ "$mode" = "move" ]; then
        lf -remote "send load"
        lf -remote "send clear"
        lf -remote "send $id reload"
    fi
}}
map p paste

cmd rsync !{{
    load=$(lf -remote 'load')
    mode=$(echo "$load" | sed -n '1p')
    list=$(echo "$load" | sed '1d')
    if [ $mode = 'copy' ]; then
        rsync -avP ${(f)list} .
        lf -remote "send $id reload"
    fi
}}
map -p rsync

cmd link %{{
    mode=""
    files=""
    lf -remote 'load' | while read file
    do
        if [ -z "$mode" ]
        then mode="$file"
        elif [ -n "$file" ]
        then
            files="yes"

            target_name="$(basename "$file")"
            if [ "$(dirname "$file")" = "$PWD" ]; then
                target_name="$target_name.link"
            fi

            if [ "$mode" = "copy" ]; then
                ln -s "$@" -T "$file" "$target_name"
            elif [ "$mode" = "move" ]; then
                ln "$@" -T "$file" "$target_name"
            fi
        fi
    done

    if [ -z "$files" ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    else
        lf -remote "send $id reload"
    fi
}}
map PP link
map Pp link -r

cmd smart_delete ${{
    echo
    echo "$fx"
    echo -n "delete? [y/N] "
    read ans
    if [ "$ans" = "y" ]
    then 
        lf -remote "send clear"
        rm -r ${(f)fx}
        lf -remote "send $id reload"
    fi
}}
map <delete> smart_delete

# move current file or selected files to trash folder
cmd trash %trash-put ${(f)fx}; lf -remote "send $id reload"
map <bs2> trash

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    set -f
    case "$f" in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf "$f" ;;
        *.tar.gz|*.tgz) tar xzvf "$f" ;;
        *.tar.xz|*.txz) tar xJvf "$f" ;;
        *.zip) unzip "$f" ;;
        *.rar) unrar x "$f" ;;
        *.7z) 7z x "$f" ;;
    esac

    lf -remote "send $id reload"
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir "$1"
    cp -a ${(f)fx} "$1"
    tar czf "$1.tar.gz" "$1"
    rm -rf "$1"

    lf -remote "send $id reload"
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir "$1"
    cp -a ${(f)fx} "$1"
    zip -r "$1.zip" "$1"
    rm -rf "$1"

    lf -remote "send $id reload"
}}

# put lf into background
map <c-z> $kill -STOP $PPID

