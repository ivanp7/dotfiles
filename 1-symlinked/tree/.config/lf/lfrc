# interpreter for shell commands (needs to be POSIX compatible)
set shell zsh

# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-eu'

# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"

# leave some space at the top and the bottom of the screen
set scrolloff 10

set color256
set drawbox on
set tabstop 4

map zp set preview!
map z1 :set nopreview; set ratios 1
map z2 set ratios 1:2
map z3 set ratios 1:2:3
map z4 set ratios 1:2:3:5
map z5 set ratios 1:2:3:5:8

set relativenumber

# cmd recol %{{
#     w=$(tput cols)
#     if [ $w -le 80 ]; then
#         lf -remote "send $id set ratios 1:2"
#     elif [ $w -le 160 ]; then
#         lf -remote "send $id set ratios 1:2:3"
#     else
#         lf -remote "send $id set ratios 1:2:3:5"
#     fi
# }}

# use enter for shell commands
# map <enter> shell

# do nothing; interrupt input
map <esc> $true

# execute current file (must be executable)
map x !"$f"
map -x push !"$f"<space>
map X &"$f"
map -X push &"$f"<space>

# create directory
cmd mkdir %mkdir "$(echo "$@")"; lf -remote "send $id reload"
map [ push ::mkdir<space>

# touch
map tt %touch ${(f)fx}; lf -remote "send $id reload"
# create file
cmd touch %touch "$(echo "$@")"; lf -remote "send $id reload"
map ] push ::touch<space>

# edit files
map e $$EDITOR ${(f)fx}

# read link
map al %readlink "$f"

# display owner & group
map ao %stat -c %U:%G "$f"

# show MIME type
map am %file --mime-type "$f" -b

# calculate used space
map au %du -ch ${(f)fx} | tail -n 1

# set permissions (a+-rwxXst)
map t+r %chmod +r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-r %chmod -r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+w %chmod +w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-w %chmod -w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+x %chmod +x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-x %chmod -x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+X %chmod +X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-X %chmod -X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+s %chmod +s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-s %chmod -s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t+t %chmod +t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map t-t %chmod -t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"

# set permissions (u+-rwxXst)
map tu+r %chmod u+r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-r %chmod u-r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+w %chmod u+w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-w %chmod u-w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+x %chmod u+x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-x %chmod u-x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+X %chmod u+X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-X %chmod u-X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+s %chmod u+s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-s %chmod u-s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu+t %chmod u+t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tu-t %chmod u-t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"

# set permissions (g+-rwxXst)
map tg+r %chmod g+r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-r %chmod g-r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+w %chmod g+w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-w %chmod g-w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+x %chmod g+x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-x %chmod g-x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+X %chmod g+X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-X %chmod g-X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+s %chmod g+s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-s %chmod g-s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg+t %chmod g+t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map tg-t %chmod g-t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"

# set permissions (o+-rwxXst)
map to+r %chmod o+r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-r %chmod o-r ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+w %chmod o+w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-w %chmod o-w ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+x %chmod o+x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-x %chmod o-x ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+X %chmod o+X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-X %chmod o-X ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+s %chmod o+s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-s %chmod o-s ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to+t %chmod o+t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"
map to-t %chmod o-t ${(f)fx}; lf -remote "send $id reload"; stat -c %A "$f"

# copy path
map Ypx $echo -n "$f" | xclip -i -selection clipboard
map Ydx $echo -n "$(dirname "$f")" | xclip -i -selection clipboard
map Ynx $echo -n "$(basename "$f")" | xclip -i -selection clipboard
map Ypt $tmux set-buffer -- "$f"
map Ydt $tmux set-buffer -- "$(dirname "$f")"
map Ynt $tmux set-buffer -- "$(basename "$f")"

# preview
cmd preview ${{
    set -f
    if ! mime_type=$(file --mime-type "$f" -bLE); then mime_type=""; fi
    case $mime_type in
        "") ;;
        image/*|video/*)
            preview.sh "$f"
            ;;
        application/zip|application/x-zip-compressed|application/vnd.rar|application/x-7z-compressed|application/x-bzip|application/x-bzip2|application/gzip|application/x-xz|application/x-iso9660-image)
            lf -remote "send $id list"
            ;;
        *) less "$f"
    esac
}}
map i preview

# dedicated keys for file opener actions
# map o &mimeopen "$f"
# map O $mimeopen --ask "$f"
cmd opener ${{
    for file in ${(f)fx}; do 
        setsid $OPENER "$file" > /dev/null 2>&1 &
    done
}}
map o opener

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
cmd open ${{
    set -f
    if ! mime_type=$(file --mime-type "$f" -bLE); then mime_type=""; fi
    case $mime_type in
        "") ;;
        image/*) 
            setsid $VIEWER ${(f)fx} > /dev/null 2>&1 & 
            ;;
        video/*|audio/*) 
            setsid $PLAYER ${(f)fx} > /dev/null 2>&1 & 
            ;;
        application/pdf) 
            setsid $PDFVIEWER ${(f)fx} > /dev/null 2>&1 & 
            ;;
        text/html) 
            for file in ${(f)fx}; do 
                setsid $BROWSER "$file" > /dev/null 2>&1 & 
            done
            ;;
        application/zip|application/x-zip-compressed|application/vnd.rar|application/x-7z-compressed|application/x-bzip|application/x-bzip2|application/gzip|application/x-xz|application/x-iso9660-image)
            postfix="-archive-mount"
            first_file=""
            for file in ${(f)fx}; do
                if [ -z "$first_file" ]; then
                    first_file="$file"
                fi
                mntdir="$file$postfix"
                [ ! -d "$mntdir" ] && {
                    mkdir -p "$mntdir"
                    archivemount "$f" "$mntdir"
                    echo "$mntdir" >> "/tmp/__lf_archivemount_$id"
                }
            done
            file="$(echo "$first_file$postfix" | sed 's/\"/\\\"/g')"
            lf -remote "send $id cd \"$file\""
            lf -remote "send $id reload"
            ;;

        *) $EDITOR ${(f)fx} ;;
    esac
}}

# glob select&unselect
map V push ::glob-select<space>
map U push ::glob-unselect<space>

cmd moveless_toggle %{{
    lf -remote "send $id toggle"
    file="$(echo "$f" | sed 's/\"/\\\"/g')"
    lf -remote "send $id select \"$file\""
}}
cmd back_toggle %{{
    lf -remote "send $id toggle"
    file="$(echo "$f" | sed 's/\"/\\\"/g')"
    lf -remote "send $id select \"$file\""
    lf -remote "send $id up"
}}
map <space> moveless_toggle
map b toggle
map B back_toggle

# define a custom 'rename' command without prompt for overwrite
# cmd rename %[ -e $1 ] && printf "file exists" || mv $f $1
# map r push :rename<space>

cmd bulk_rename !{{
    original_names_file=$(mktemp)
    changed_names_file=$(mktemp)
    for file in ${(f)fs}
    do 
        echo "$file" >> $original_names_file
        echo "$file" >> $changed_names_file
    done
    $EDITOR $changed_names_file

    NAME_FIX="s/'/'\\\\''/g; s/^/'/; s/\$/'/"
    sed -i "$NAME_FIX" $original_names_file
    sed -i "$NAME_FIX" $changed_names_file

    if [ "$(cat $original_names_file | wc -l)" -ne "$(cat $changed_names_file | wc -l)" ]
    then
        echo "Error: number of lines is not equal to the number of files."
    else
        commands_file=$(mktemp)
        paste -d" " $original_names_file $changed_names_file > $commands_file
        rm $original_names_file $changed_names_file
        sed -i 's/^/mv -vi -- /' $commands_file
        $EDITOR $commands_file

        for cmd in $(cat $commands_file)
        do $SHELL -c "$cmd; true"
        done
        rm $commands_file
    fi
}}

cmd smart_rename ${{
    if [ -z "$fs" ]
    then lf -remote "send $id rename"
    else lf -remote "send $id bulk_rename"
    fi

    lf -remote "send $id reload"
}}

map r smart_rename
map R %vidir ${(f)fs}; lf -remote "send $id reload"

cmd paste %{{
    mode=""
    files=""
    lf -remote 'load' | while read file
    do
        if [ -z "$mode" ]
        then mode="$file"
        elif [ -n "$file" ]
        then
            files="yes"

            if [ "$mode" = "copy" ]; then
                target_name="$(basename "$file")"
                if [ "$(dirname "$file")" = "$PWD" ]; then
                    if [ ! -d "$file" ] || [ -L "$file" ] || [ ! -e "$target_name.copy" ]; then
                        target_name="$target_name.copy"
                    fi
                fi

                cp --backup=numbered -aT "$file" "$target_name"
            elif [ "$mode" = "move" ]; then
                if [ "$(dirname "$file")" != "$PWD" ]; then
                    mv --backup=numbered -t . "$file"
                fi
            fi
        fi
    done

    if [ -z "$files" ]; then
        lf -remote "send $id echo no files to paste"
        exit 0
    elif [ "$mode" = "move" ]; then
        lf -remote "send load"
        lf -remote "send clear"
        lf -remote "send $id reload"
    fi
}}
map p paste

cmd rsync !{{
    load=$(lf -remote 'load')
    mode=$(echo "$load" | sed -n '1p')
    list=$(echo "$load" | sed '1d')
    if [ $mode = 'copy' ]; then
        rsync -avP ${(f)list} .
        lf -remote "send $id reload"
    fi
}}
map -p rsync

cmd link %{{
    mode=""
    files=""
    lf -remote 'load' | while read file
    do
        if [ -z "$mode" ]
        then mode="$file"
        elif [ -n "$file" ]
        then
            files="yes"

            target_name="$(basename "$file")"
            if [ "$(dirname "$file")" = "$PWD" ]; then
                target_name="$target_name.link"
            fi

            if [ "$mode" = "copy" ]; then
                ln -s "$@" -T "$file" "$target_name"
            elif [ "$mode" = "move" ]; then
                ln "$@" -T "$file" "$target_name"
            fi
        fi
    done

    if [ -z "$files" ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    else
        lf -remote "send $id reload"
    fi
}}
map PP link
map Pp link -r

cmd smart_delete ${{
    echo
    echo "$fx"
    echo -n "delete? [y/N] "
    read ans
    if [ "$ans" = "y" ]
    then 
        lf -remote "send clear"
        rm -rf ${(f)fx}
        lf -remote "send $id reload"
    fi
}}
map <delete> smart_delete

# move current file or selected files to trash folder
cmd trash %trash-put ${(f)fx}; lf -remote "send $id reload"
map <bs2> trash

# extract the current file with the right command
# (xkcd link: https://xkcd.com/1168/)
cmd extract ${{
    prepare_dir ()
    {
        contents_dir="$1-archive-contents"
        mkdir "$contents_dir"
        cd "$contents_dir"
    }

    for file in ${(f)fx}; do
        if ! mime_type=$(file --mime-type "$f" -bLE); then mime_type=""; fi
        case $mime_type in
            "") ;;
            application/zip|application/x-zip-compressed)
                prepare_dir "$file"; unzip "$file" ;;
            application/vnd.rar)
                prepare_dir "$file"; unrar x "$file" ;;
            application/x-7z-compressed|application/x-iso9660-image)
                prepare_dir "$file"; 7z x "$file" ;;
            application/x-bzip|application/x-bzip2)
                prepare_dir "$file"; tar xjvf "$file" ;;
            application/gzip)
                prepare_dir "$file"; tar xzvf "$file" ;;
            application/x-xz)
                prepare_dir "$file"; tar xJvf "$file" ;;
        esac
    done

    lf -remote "send $id reload"
}}

# list archive contents
cmd list !{{
    if ! mime_type=$(file --mime-type "$f" -bLE); then mime_type=""; fi
    case $mime_type in
        "") ;;
        application/zip|application/x-zip-compressed)
            unzip -l "$f" ;;
        application/vnd.rar)
            unrar l "$f" ;;
        application/x-7z-compressed|application/x-iso9660-image)
            7z l "$f" ;;
        application/x-bzip|application/x-bzip2)
            tar tjvf "$f" ;;
        application/gzip)
            tar tzvf "$f" ;;
        application/x-xz)
            tar tJvf "$f" ;;
    esac
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    tmpdir=$(mktemp -d -p .)
    cp -a ${(f)fx} $tmpdir/

    cd $tmpdir
    tar cJf "$1.tar.xz" ./*
    mv "$1.tar.xz" ../
    cd ..
    rm -rf $tmpdir

    lf -remote "send $id reload"
}}

# compress current file or selected files with zip
cmd zip ${{
    tmpdir=$(mktemp -d -p .)
    cp -a ${(f)fx} $tmpdir/

    cd $tmpdir
    zip -r "$1.zip" ./*
    mv "$1.zip" ../
    cd ..
    rm -rf $tmpdir

    lf -remote "send $id reload"
}}

# compress current file or selected files with 7z
cmd 7z ${{
    tmpdir=$(mktemp -d -p .)
    cp -a ${(f)fx} $tmpdir/

    cd $tmpdir
    7z a "$1.7z" ./*
    ls
    mv "$1.7z" ../
    cd ..
    rm -rf $tmpdir

    lf -remote "send $id reload"
}}

# put lf into background
map <c-z> $kill -STOP $PPID

