# interpreter for shell commands (needs to be POSIX compatible)
set shell zsh

# set '-eu' options for shell commands
# These options are used to have safer shell commands. Option '-e' is used to
# exit on error and option '-u' is used to give error for unset variables.
# Option '-f' disables pathname expansion which can be useful when $f, $fs, and
# $fx variables contain names with '*' or '?' characters. However, this option
# is used selectively within individual commands as it can be limiting at
# times.
set shellopts '-eu'

# set internal field separator (IFS) to "\n" for shell commands
# This is useful to automatically split file names in $fs and $fx properly
# since default file separator used in these variables (i.e. 'filesep' option)
# is newline. You need to consider the values of these options and create your
# commands accordingly.
set ifs "\n"

# leave some space at the top and the bottom of the screen
set scrolloff 10

set color256
set drawbox on
set tabstop 4

map zp set preview!
map z1 :set nopreview; set ratios 1
map z2 set ratios 1:2
map z3 set ratios 1:2:3
map z4 set ratios 1:2:3:5
map z5 set ratios 1:2:3:5:8

set relativenumber

set previewer ~/.scripts/df/lf-previewer.sh

# unmap default mappings
map gh

# do nothing; interrupt input
map <esc> $true

# execute current file (must be executable)
map x !"$f"
map -x push !"$f"<space>
map X &setsid "$f"
map -X push &setsid "$f"<space>

# create directory
cmd mkdir %mkdir "$(echo "$@")"; lf -remote "send $id reload"
map [ push ::mkdir<space>

# touch
map tt %touch ${(f)fx}; lf -remote "send $id reload"
# create file
cmd touch %touch "$(echo "$@")"; lf -remote "send $id reload"
map ] push ::touch<space>

# read link
map al %readlink "$f"

# display owner & group
map ao %stat -c %U:%G "$f"

# show MIME type
cmd link_mime %{{
    mime_type=$(file --mime-type "$f" -bLE) || mime_type=""
    echo $mime_type
}}
map am %file --mime-type "$f" -b
map aM link_mime

# calculate used space
map au %du -ch ${(f)fx} | tail -n 1

cmd setperm %{{
    chmod $1 ${(f)fx}
    lf -remote "send $id reload"
    stat -c %A "$f"
}}

# set permissions (a+-rwxXst)
map t+r setperm +r
map t-r setperm -r
map t+w setperm +w
map t-w setperm -w
map t+x setperm +x
map t-x setperm -x
map t+X setperm +X
map t-X setperm -X
map t+s setperm +s
map t-s setperm -s
map t+t setperm +t
map t-t setperm -t

# set permissions (u+-rwxXst)
map tu+r setperm u+r
map tu-r setperm u-r
map tu+w setperm u+w
map tu-w setperm u-w
map tu+x setperm u+x
map tu-x setperm u-x
map tu+X setperm u+X
map tu-X setperm u-X
map tu+s setperm u+s
map tu-s setperm u-s
map tu+t setperm u+t
map tu-t setperm u-t

# set permissions (g+-rwxXst)
map tg+r setperm g+r
map tg-r setperm g-r
map tg+w setperm g+w
map tg-w setperm g-w
map tg+x setperm g+x
map tg-x setperm g-x
map tg+X setperm g+X
map tg-X setperm g-X
map tg+s setperm g+s
map tg-s setperm g-s
map tg+t setperm g+t
map tg-t setperm g-t

# set permissions (o+-rwxXst)
map to+r setperm o+r
map to-r setperm o-r
map to+w setperm o+w
map to-w setperm o-w
map to+x setperm o+x
map to-x setperm o-x
map to+X setperm o+X
map to-X setperm o-X
map to+s setperm o+s
map to-s setperm o-s
map to+t setperm o+t
map to-t setperm o-t

# copy path
map Ypx $echo -n "$f" | xclip -i -selection clipboard
map Ydx $echo -n "$(dirname "$f")" | xclip -i -selection clipboard
map Ynx $echo -n "$(basename "$f")" | xclip -i -selection clipboard
map Ypt $tmux set-buffer -- "$f"
map Ydt $tmux set-buffer -- "$(dirname "$f")"
map Ynt $tmux set-buffer -- "$(basename "$f")"

# preview
cmd preview ${{
    set -f
    mime_type=$(file --mime-type "$f" -bLE) || mime_type=""
    case $mime_type in
        "") ;;
        inode/directory)
            tree -ad -L 3 -I ".git" -n "$f" | sed 's/Â / /g' | $PAGER ;;
        image/*|video/*)
            preview.sh "$f"
            read -sk
            ;;
        application/*)
            case $(echo $mime_type | tail -c +13) in
                pdf) 
                    pdftotext -layout "$f" - | $PAGER ;;
                x-tar)
                    tar tvf "$f" | $PAGER ;;
                x-bzip|x-bzip2)
                    tar tjvf "$f" | $PAGER ;;
                gzip)
                    tar tzvf "$f" | $PAGER ;;
                x-xz)
                    tar tJvf "$f" | $PAGER ;;
                zstd)
                    tar tvf "$f" --zstd | $PAGER ;;
                zip|x-zip-compressed)
                    unzip -l "$f" | $PAGER ;;
                x-7z-compressed|x-iso9660-image)
                    7z l "$f" | $PAGER ;;
                x-rar|vnd.rar)
                    unrar l "$f" | $PAGER ;;
                x-cpio)
                    bsdcpio -i -t -I "$f" | $PAGER ;;
                pgp|pgp-encrypted)
                    gpg -d "$f" | $PAGER ;;
                *) $PAGER "$f"
            esac
            ;;
        *) $PAGER "$f"
    esac
}}
map i preview
map I $$PAGER "$f"
map -I !cat "$f"

# edit files
map e $$EDITOR ${(f)fx}

# dedicated keys for file opener actions
# map o &mimeopen "$f"
# map O $mimeopen --ask "$f"
cmd opener ${{
    for file in ${(f)fx}; do 
        setsid $OPENER "$file" > /dev/null 2>&1 &
    done
}}
map o opener

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
cmd open ${{
    set -f
    mime_type=$(file --mime-type "$f" -bLE) || mime_type=""
    case $mime_type in
        "") ;;
        image/*)
            setsid $VIEWER ${(f)fx} > /dev/null 2>&1 & ;;
        video/*|audio/*)
            setsid $PLAYER ${(f)fx} > /dev/null 2>&1 & ;;
        text/html)
            for file in ${(f)fx}; do 
                setsid $BROWSER "$file" > /dev/null 2>&1 & 
            done
            ;;
        application/*)
            case $(echo $mime_type | tail -c +13) in
                pdf)
                    setsid $PDFVIEWER ${(f)fx} > /dev/null 2>&1 & ;;
                x-bzip|x-bzip2|gzip|x-xz|zip|x-zip-compressed|x-7z-compressed|x-iso9660-image|x-rar|vnd.rar|x-cpio)
                    postfix="-archive-mount"
                    first_file=""
                    for file in ${(f)fx}; do
                        if [ -z "$first_file" ]; then
                            first_file="$file"
                        fi
                        mntdir="$file$postfix"
                        [ ! -d "$mntdir" ] && {
                            mkdir -p "$mntdir"
                            archivemount "$f" "$mntdir"
                            echo "$mntdir" >> "/tmp/__lf_archivemount_$id"
                        }
                    done
                    file="$(echo "$first_file$postfix" | sed 's/\"/\\\"/g')"
                    lf -remote "send $id cd \"$file\""
                    lf -remote "send $id reload"
                    ;;
                *) $EDITOR ${(f)fx}
            esac
            ;;
        *) $EDITOR ${(f)fx}
    esac
}}

# glob select&unselect
map V push ::glob-select<space>
map U push ::glob-unselect<space>

cmd moveless_toggle %{{
    lf -remote "send $id toggle"
    file="$(echo "$f" | sed 's/\"/\\\"/g')"
    lf -remote "send $id select \"$file\""
}}
cmd back_toggle %{{
    lf -remote "send $id toggle"
    file="$(echo "$f" | sed 's/\"/\\\"/g')"
    lf -remote "send $id select \"$file\""
    lf -remote "send $id up"
}}
map <space> moveless_toggle
map b toggle
map B back_toggle

# smart rename
cmd bulk_rename !{{
    original_names_file=$(mktemp)
    changed_names_file=$(mktemp)
    for file in ${(f)fs}
    do 
        echo "$file" >> $original_names_file
        echo "$file" >> $changed_names_file
    done
    $EDITOR $changed_names_file

    NAME_FIX="s/'/'\\\\''/g; s/^/'/; s/\$/'/"
    sed -i "$NAME_FIX" $original_names_file
    sed -i "$NAME_FIX" $changed_names_file

    if [ "$(cat $original_names_file | wc -l)" -ne "$(cat $changed_names_file | wc -l)" ]
    then
        echo "Error: number of lines is not equal to the number of files."
    else
        commands_file=$(mktemp)
        paste -d" " $original_names_file $changed_names_file > $commands_file
        rm $original_names_file $changed_names_file
        sed -i 's/^/mv -vi -- /' $commands_file
        $EDITOR $commands_file

        for cmd in $(cat $commands_file)
        do $SHELL -c "$cmd; true"
        done
        rm $commands_file
    fi
}}

cmd smart_rename ${{
    if [ -z "$fs" ]
    then lf -remote "send $id rename"
    else lf -remote "send $id bulk_rename"
    fi

    lf -remote "send $id reload"
}}

map r smart_rename
map R %vidir ${(f)fs}; lf -remote "send $id reload"

# pasting done right
cmd paste %{{
    mode=""
    files=""
    lf -remote 'load' | while read file
    do
        if [ -z "$mode" ]
        then mode="$file"
        elif [ -n "$file" ]
        then
            files="yes"

            if [ "$mode" = "copy" ]; then
                target_name="$(basename "$file")"
                if [ "$(dirname "$file")" = "$PWD" ]; then
                    if [ ! -d "$file" ] || [ -L "$file" ] || [ ! -e "$target_name.copy" ]; then
                        target_name="$target_name.copy"
                    fi
                fi

                cp --backup=numbered -aT "$file" "$target_name"
            elif [ "$mode" = "move" ]; then
                if [ "$(dirname "$file")" != "$PWD" ]; then
                    mv --backup=numbered -t . "$file"
                fi
            fi
        fi
    done

    if [ -z "$files" ]; then
        lf -remote "send $id echo no files to paste"
        exit 0
    elif [ "$mode" = "move" ]; then
        lf -remote "send load"
        lf -remote "send clear"
        lf -remote "send $id reload"
    fi
}}
map p paste

cmd rsync !{{
    load=$(lf -remote 'load')
    mode=$(echo "$load" | sed -n '1p')
    list=$(echo "$load" | sed '1d')
    if [ $mode = 'copy' ]; then
        rsync -avP ${(f)list} .
        lf -remote "send $id reload"
    fi
}}
map -p rsync

# links
cmd link %{{
    mode=""
    files=""
    lf -remote 'load' | while read file
    do
        if [ -z "$mode" ]
        then mode="$file"
        elif [ -n "$file" ]
        then
            files="yes"

            target_name="$(basename "$file")"
            if [ "$(dirname "$file")" = "$PWD" ]; then
                target_name="$target_name.link"
            fi

            if [ "$mode" = "copy" ]; then
                ln -s "$@" -T "$file" "$target_name"
            elif [ "$mode" = "move" ]; then
                ln "$@" -T "$file" "$target_name"
            fi
        fi
    done

    if [ -z "$files" ]; then
        lf -remote "send $id echo no files to link"
        exit 0
    else
        lf -remote "send $id reload"
    fi
}}
map PP link
map Pp link -r

# delete files & directories
cmd smart_delete ${{
    echo
    echo "$fx"
    echo -n "delete? [y/N] "
    read ans
    if [ "$ans" = "y" ]
    then 
        lf -remote "send clear"
        rm -rf ${(f)fx}
        lf -remote "send $id reload"
    fi
}}
map <delete> smart_delete

# move current file or selected files to trash folder
cmd trash %trash-put ${(f)fx}; lf -remote "send $id reload"
map <bs2> trash

# extract the current file or selected files with the right command
cmd extract ${{
    for file in ${(f)fx}; do
        extract.sh "$file"
    done
    lf -remote "send $id reload"
}}

# compress current file or selected files
cmd compress ${{
    compress.sh $1 "$2" ${(f)fx}
    lf -remote "send $id reload"
}}

cmd tar ${{
    file="$(echo "$1" | sed 's/\"/\\\"/g')"
    lf -remote "send $id compress tar \"$file\""
}}

cmd gz ${{
    file="$(echo "$1" | sed 's/\"/\\\"/g')"
    lf -remote "send $id compress gz \"$file\""
}}

cmd xz ${{
    file="$(echo "$1" | sed 's/\"/\\\"/g')"
    lf -remote "send $id compress xz \"$file\""
}}

cmd zstd ${{
    file="$(echo "$1" | sed 's/\"/\\\"/g')"
    lf -remote "send $id compress zstd \"$file\""
}}

cmd zip ${{
    file="$(echo "$1" | sed 's/\"/\\\"/g')"
    lf -remote "send $id compress zip \"$file\""
}}

cmd 7z ${{
    file="$(echo "$1" | sed 's/\"/\\\"/g')"
    lf -remote "send $id compress 7z \"$file\""
}}

cmd encrypt ${{
    for file in ${(f)fx}; do
        echo "$file"
        gpg "$@" --symmetric "$file"
    done
    lf -remote "send $id reload"
}}

cmd decrypt ${{
    for file in ${(f)fx}; do
        echo "$file"
        decrypted_file="$(echo "$file" | sed -E 's/\.(gpg|asc)$//')"
        [ "$decrypted_file" != "$file" ] || decrypted_file="$file.decrypted"
        gpg -o "$decrypted_file" -d "$file"
    done
    lf -remote "send $id reload"
}}

# put lf into background
map <c-z> $kill -STOP $PPID

