# Auxilliary constants & functions {{{

_p_prompt_character ()
{
    [ "$(id -u)" -ne 0 ] && echo "$" || echo "#"
}

[ -z "$_p_interactive_shells" ] &&
    export _p_interactive_shells="$(_p_prompt_character)" ||
    export _p_interactive_shells="${_p_interactive_shells}$(_p_prompt_character)"

_p_dot="·"
_p_bullet="•"
_p_rightarrow="→"
_p_uparrow="↑"
_p_downarrow="↓"
_p_updownarrow="↕"

# }}}
# Prompt counter {{{

_p_command_number_f ()
{
    # [ -n "$_p_command_executed" ] && _p_command_number=$(($_p_command_number+1))
    [ -n "$_p_command_number" ] &&
        export _p_command_number=$(($_p_command_number+1)) ||
        export _p_command_number=1
}
add-zsh-hook precmd _p_command_number_f

_p_prompt_info_f ()
{
    local BgColor="$(_color 244 238)"

    _p_prompt_info_length=$((1 + ${#_p_interactive_shells} + 1 + ${#_p_command_number} + 1))
    _p_prompt_info="${BgColor} ${_p_interactive_shells}${_p_dot}${_p_command_number} "
}
add-zsh-hook precmd _p_prompt_info_f

_p_prev_command_info_f ()
{
    _p_exitcode="$?" # This needs to be first

    if [ -n "$_p_command_executed" ]
    then
        unset _p_command_executed

        if [ -n "$_p_timer" ]
        then
            _p_timer_delta=$(($SECONDS - $_p_timer))
            [ $_p_timer_delta -lt 0 ] && _p_timer_delta=0
            unset _p_timer
        fi
    else
        unset _p_timer_delta
        unset _p_exitcode
    fi

    _p_in_prompt=true
}
add-zsh-hook precmd _p_prev_command_info_f

_p_preexec ()
{
    unset _p_in_prompt
    _p_timer=${_p_timer:-$SECONDS}
    _p_command_executed=true

    _p_prompt_postcommand_preexec
}
add-zsh-hook preexec _p_preexec

# }}}
# Last command duration {{{

_p_cmdtimeinfo_f ()
{
    if [ -z "$_p_timer_delta" ]
    then
        _p_cmdtimeinfo_length=0
        _p_cmdtimeinfo=""
        return
    fi

    if [ "$_p_timer_delta" -eq 0 ]
    then
        _p_cmdtimeinfo_length=0
        _p_cmdtimeinfo=""
        return
    fi

    if [ "$_colors" -ge 256 ]
    then
        local BgColor=$(_color 0 33)
    else
        local BgColor=$(_color 0 6)
    fi

    local UnitColor=$(_color 248)
    local SecondsColor=$(_color 15)
    local MinutesColor=$(_color 15)
    local HoursColor=$(_color 15)
    local DaysColor=$(_color 15)

    local delta_minutes="$((${_p_timer_delta} / 60))"
    local delta_hours="$((${delta_minutes} / 60))"
    local delta_days="$((${delta_hours} / 24))"

    local seconds_digits="$((${_p_timer_delta} % 60))"
    local seconds="${SecondsColor}${seconds_digits}${UnitColor}s"
    if [ "$delta_minutes" -gt 0 ]
    then
        local minutes_digits="$((${delta_minutes} % 60))"
        local minutes="${MinutesColor}${minutes_digits}${UnitColor}m"
        local minutes_length=$((${#minutes_digits} + 1))
    fi
    if [ "$delta_hours" -gt 0 ]
    then
        local hours_digits="$((${delta_hours} % 24))"
        local hours="${HoursColor}${hours_digits}${UnitColor}h"
        local hours_length=$((${#hours_digits} + 1))
    fi
    if [ "$delta_days" -gt 0 ]
    then
        local days_digits="${delta_days}"
        local days="${DaysColor}${days_digits}${UnitColor}d"
        local days_length=$((${#days_digits} + 1))
    fi

    _p_cmdtimeinfo_length=$((2 + $days_length + $hours_length +
    $minutes_length + ${#seconds_digits} + 1))
    _p_cmdtimeinfo="${BgColor} ${days}${hours}${minutes}${seconds} "
}
add-zsh-hook precmd _p_cmdtimeinfo_f

# }}}
# Last command status {{{

_p_cmdstatusinfo_f ()
{
    if [ "$_colors" -ge 256 ]
    then
        local SuccessColor="$(_color_reset)$(_color 7 35)"
        local FailureColor="$(_color_reset)$(_color 0 196)"
    else
        local SuccessColor="$(_color_reset)$(_color 7 2)"
        local FailureColor="$(_color_reset)$(_color 0 1)"
    fi

    if [ -n "$_p_exitcode" ]
    then
        if [ "$_p_exitcode" -eq 0 ]
        then
            _p_cmdstatusinfo_length=4
            _p_cmdstatusinfo="${SuccessColor} ${_p_downarrow}0 "
        else
            _p_cmdstatusinfo_length=$((3 + ${#_p_exitcode}))
            _p_cmdstatusinfo="${FailureColor} ${_p_downarrow}${_p_exitcode} "
        fi
    else
        _p_cmdstatusinfo_length=0
        _p_cmdstatusinfo=""
    fi
}
add-zsh-hook precmd _p_cmdstatusinfo_f

# }}}
# git info {{{

_p_gitinfo_f ()
{
    local BgColor=$(_color 0 238)
    local LocationColor="$(_color 228)"

    # Exit if not inside a Git repository
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1
    then
        _p_gitinfo_length=0
        _p_gitinfo=""
        return
    fi

    # Git branch/tag, or name-rev if on detached head
    local GIT_LOCATION=${$(git symbolic-ref -q HEAD || git name-rev --name-only --no-undefined --always HEAD)#(refs/heads/|tags/)}
    _p_gitinfo_length=$((2 + ${#GIT_LOCATION}))

    # Exit if inside a .git directory
    if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" = "true" ]
    then
        local DotGitWarningColor=$(_color 1)

        _p_gitinfo_length=$(($_p_gitinfo_length + 5))
        _p_gitinfo="${BgColor} ${LocationColor}$GIT_LOCATION ${DotGitWarningColor}.git "
        return
    fi

    local AheadColor="$(_color 15)"
    local BehindColor="$(_color 166)"

    local MergingColor="$(_color 33)"
    local UntrackedColor="$(_color 160)"
    local ModifiedColor="$(_color 214)"
    local StagedColor="$(_color 34)"

    local AHEAD="${AheadColor}${_p_uparrow}NUM"
    local BEHIND="${BehindColor}${_p_downarrow}NUM"

    local MERGING="${MergingColor}${_p_updownarrow}"
    local UNTRACKED="${UntrackedColor}${_p_bullet}"
    local MODIFIED="${ModifiedColor}${_p_bullet}"
    local STAGED="${StagedColor}${_p_bullet}"

    local -a DIVERGENCES
    local -a FLAGS

    local NUM_AHEAD="$(git log --oneline @{u}.. 2> /dev/null | wc -l | tr -d ' ')"
    if [ "$NUM_AHEAD" -gt 0 ]
    then
        local _p_gitinfo_div=true
        _p_gitinfo_length=$(($_p_gitinfo_length + 1 + ${#NUM_AHEAD}))
        DIVERGENCES+=( "${AHEAD//NUM/$NUM_AHEAD}" )
    fi

    local NUM_BEHIND="$(git log --oneline ..@{u} 2> /dev/null | wc -l | tr -d ' ')"
    if [ "$NUM_BEHIND" -gt 0 ]
    then
        local _p_gitinfo_div=true
        _p_gitinfo_length=$(($_p_gitinfo_length + 1 + ${#NUM_BEHIND}))
        DIVERGENCES+=( "${BEHIND//NUM/$NUM_BEHIND}" )
    fi

    [ -n "$_p_gitinfo_div" ] && _p_gitinfo_length=$(($_p_gitinfo_length + 1))

    local GIT_DIR="$(git rev-parse --git-dir 2> /dev/null)"
    if [ -n "$GIT_DIR" -a -r "$GIT_DIR/MERGE_HEAD" ]
    then
        local _p_gitinfo_flag=true
        _p_gitinfo_length=$(($_p_gitinfo_length + 1))
        FLAGS+=( "$MERGING" )
    fi

    if [ -n "$(git ls-files $(git rev-parse --show-toplevel) --other --exclude-standard 2> /dev/null)" ]
    then
        local _p_gitinfo_flag=true
        _p_gitinfo_length=$(($_p_gitinfo_length + 1))
        FLAGS+=( "$UNTRACKED" )
    fi

    if ! git diff --quiet 2> /dev/null
    then
        local _p_gitinfo_flag=true
        _p_gitinfo_length=$(($_p_gitinfo_length + 1))
        FLAGS+=( "$MODIFIED" )
    fi

    if ! git diff --cached --quiet 2> /dev/null
    then
        local _p_gitinfo_flag=true
        _p_gitinfo_length=$(($_p_gitinfo_length + 1))
        FLAGS+=( "$STAGED" )
    fi

    [ -n "$_p_gitinfo_flag" ] && _p_gitinfo_length=$(($_p_gitinfo_length + 1))

    local -a GIT_INFO
    GIT_INFO+=( "${LocationColor}$GIT_LOCATION" )
    [ "${#DIVERGENCES[@]}" -ne 0 ] && GIT_INFO+=( "${(j::)DIVERGENCES}" )
    [ "${#FLAGS[@]}" -ne 0 ] && GIT_INFO+=( "${(j::)FLAGS}" )
    _p_gitinfo="${BgColor} ${(j: :)GIT_INFO} "
}
add-zsh-hook precmd _p_gitinfo_f

# }}}
# Current directory {{{

_p_pwdinfo_f ()
{
    local PromptLength=$(($_p_prompt_info_length + $_p_cmdtimeinfo_length + $_p_cmdstatusinfo_length + $_p_gitinfo_length + 2))
    local MaxOutputLength=$(($COLUMNS - $PromptLength))

    if [ "$(($_p_gitinfo_length * 2))" -ge "$MaxOutputLength" ]
    then
        local MaxOutputLength=$(($MaxOutputLength + $_p_gitinfo_length))
        _p_gitinfo_length=0
        unset _p_gitinfo
    fi

    local BgColor=$(_color 0 240)
    local DirColor=$(_color 15)
    local SlashColor=$(_color 236)
    local DirColoringRegEx="s@/@$SlashColor/$DirColor@g"

    local SkipColor=$(_color 1)
    local SkipRegEx='s@/(.)([^/][^/]+)/@/\1~/@'
    local SkipColoringRegEx="s@~/@$SkipColor~$SlashColor/@"
    local SkipCounter=0

    local DirPath="$PWD/"
    local DirPathShorter="$(echo "$DirPath" | sed -E "$SkipRegEx")"

    while [ "$((${#DirPath} - 1))" -gt "$MaxOutputLength" -a "${#DirPathShorter}" -lt "${#DirPath}" ]
    do
        local DirPath="$DirPathShorter"
        local DirPathShorter="$(echo "$DirPath" | sed -E "$SkipRegEx")"
        local SkipCounter=$(($SkipCounter + 1))
    done

    for i in $(seq $SkipCounter)
    do local DirPath="$(echo "$DirPath" | sed -E "$SkipColoringRegEx")"
    done
    unset i

    local DirPath="${DirPath:0:-1}"
    local DirPath="$(echo "$DirPath" | sed -E "$DirColoringRegEx")"

    if [ "$PWD" != "/" ]
    then
        local DirCounter=1
        while echo "$DirPath" | grep -q "/"
        do
            local DirPath="$(echo "$DirPath" | sed -E "s@\/([^/]*)\$@$DirCounter\1@")"
            local DirCounter=$((($DirCounter + 1) % 10))
        done
    fi

    _p_pwdinfo="${BgColor} $DirColor$DirPath "
}
add-zsh-hook precmd _p_pwdinfo_f

# }}}
# Prompt {{{

_p_set_cursor_shape ()
{
    case $1 in
        block) echo -ne '\e[2 q' ;;
        underline) echo -ne '\e[4 q' ;;
        bar) echo -ne '\e[6 q' ;;
    esac
}

_p_set_insert_prompt ()
{
    RPROMPT=""
    _p_set_cursor_shape bar
}

_p_set_vicommand_prompt ()
{
    RPROMPT="%{$(_color 0 15)%}vicmd%{$(_color_reset)%}"
    _p_set_cursor_shape block
}

_p_set_abandoned_prompt ()
{
    RPROMPT=""
    _p_set_cursor_shape block
}

_p_prompt_init_f ()
{
    _p_set_insert_prompt
}
add-zsh-hook precmd _p_prompt_init_f

zle-keymap-select ()
{
    [ "$KEYMAP" = "vicmd" ] && _p_set_vicommand_prompt || _p_set_insert_prompt
    zle reset-prompt
}
zle -N zle-keymap-select

zle-line-init ()
{
    (( ${+terminfo[smkx]} )) && echoti smkx

    _p_set_insert_prompt
    zle reset-prompt
}
zle -N zle-line-init

zle-line-finish ()
{
    (( ${+terminfo[rmkx]} )) && echoti rmkx

    _p_set_abandoned_prompt
    zle reset-prompt
}
zle -N zle-line-finish

_p_prompt_postcommand_preexec ()
{
    echo "$(_color_reset)"
}

# Fix a bug when you C-c in CMD mode and you'd be prompted with CMD mode indicator, while in fact you would be in INS mode
# Fixed by catching SIGINT (C-c), set vim_mode to INS and then repropagate the SIGINT, so if anything else depends on it, we will not break it
TRAPINT ()
{
    _p_set_abandoned_prompt
    zle && { zle reset-prompt; zle -R; }
    return $(( 128 + $1 ))
}

_p_prompt_on_exit ()
{
    unset _p_in_prompt
}

_p_trap_exit ()
{
    [ -n "$_p_in_prompt" ] && _p_set_abandoned_prompt
}
trap '_p_trap_exit' EXIT

_p_prompt ()
{
    echo "$(_color_reset)"
    echo "${_p_prompt_info}${_p_cmdtimeinfo}${_p_cmdstatusinfo}${_p_pwdinfo}${_p_gitinfo}$(_color_reset)"

    PROMPT=""
    PROMPT2=""
    RPROMPT=""
    _p_set_insert_prompt
}
add-zsh-hook precmd _p_prompt

# }}}

# vim: ft=zsh: foldmethod=marker:
