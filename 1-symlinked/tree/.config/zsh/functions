# auxilliary functions and variables {{{

_colors=$(tput colors)

_color ()
{
    [ -z "$2" ] &&
        echo -en "\033[38;5;${1}m" ||
        echo -en "\033[38;5;${1}m\033[48;5;${2}m"
}

_color_reset ()
{
    echo -en "\033[0m"
}

# }}}
# separator {{{

separator ()
{
    echo "$(_color 15)$(dd if=/dev/zero bs=1 count=$COLUMNS status=none | sed "s/./·/g")$(_color_reset)"
}

spectrum ()
{
    # Based on: https://gist.github.com/XVilka/8346728
    # echo $COLORTERM
    awk -v term_cols="$(tput cols)" 'BEGIN{
        s="··";
        for (colnum = 0; colnum<term_cols; colnum++) {
            r = 255-(colnum*255/term_cols);
            g = (colnum*510/term_cols);
            b = (colnum*255/term_cols);
            if (g>255) g = 510-g;
                printf "\033[48;2;%d;%d;%dm", r,g,b;
                printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
                printf "%s\033[0m", substr(s,colnum%2+1,1);
            }
        printf "\n";
    }'
}

# }}}
# shell info {{{

userhost ()
{
    local UserColor="$(_color 15)"
    [ "$(id -u)" -eq 0 ] && UserColor="$(_color 196)"
    local AtColor="$(_color 244)"
    local HostColor="$(_color 15)"

    echo "$(_color_reset)${UserColor}$USERNAME${AtColor}@${HostColor}$HOST$(_color_reset)"
}

process_chain ()
{
    local ProcessTreeStr="$_pstree"
    [ -z "$ProcessTreeStr" ] && return

    local ProcNameColor="$(_color 15)"
    local OtherColor="$(_color 244)"
    local bra=" "
    local ket=" "
    local right_arrow="→"
    local PrettifyingRegEx='s@---@'"${OtherColor}$ket${right_arrow}$bra${ProcNameColor}"'@g'

    local ProcessTreeStr="$(echo "$ProcessTreeStr" | sed -E "$PrettifyingRegEx")"
    echo "$(_color_reset)${ProcNameColor}${ProcessTreeStr}$(_color_reset)"
}

shell_info ()
{
    local TextColor="$(_color 244)"
    local ValueColor="$(_color 15)"
    local Login=
    [[ -o login ]] && local Login="login "

    echo "${TextColor}current date/time: ${ValueColor}$(date)$(_color_reset)"
    echo "${TextColor}device: ${ValueColor}$TTY${TextColor}, terminal: ${ValueColor}$TERM${TextColor}, ${ValueColor}${COLUMNS}${TextColor}x${ValueColor}${LINES}${TextColor} cells, ${ValueColor}${_colors}${TextColor} colors$(_color_reset)"
    echo "${TextColor}process chain: $(process_chain)"
    echo "${TextColor}running ${Login}${ValueColor}$SHELL${TextColor} shell as $(userhost)$(_color_reset)"
}

# }}}
# colors {{{

colorgrid ()
{
    local iter=0
    while [ $iter -lt 16 ]
    do
        echo -en "\033[48;5;$(echo $iter)m \033[0m\033[38;5;$(echo $iter)m█ "
        printf "%03d" $iter

        [ $(($iter % 8)) = 7 ] && printf '\r\n' || printf ' '

        local iter=$(($iter+1))
    done

    printf '\r\n'

    local iter=16
    while [ $iter -lt 52 ]
    do
        local second=$(($iter+36))
        local third=$(($second+36))
        local fourth=$(($third+36))
        local fifth=$(($fourth+36))
        local sixth=$(($fifth+36))
        local seventh=$(($sixth+36))

        echo -en "\033[48;5;$(echo $iter)m \033[0m\033[38;5;$(echo $iter)m█ "
        printf "%03d" $iter
        echo -en " \033[48;5;$(echo $second)m \033[0m\033[38;5;$(echo $second)m█ "
        printf "%03d" $second
        echo -en " \033[48;5;$(echo $third)m \033[0m\033[38;5;$(echo $third)m█ "
        printf "%03d" $third
        echo -en " \033[48;5;$(echo $fourth)m \033[0m\033[38;5;$(echo $fourth)m█ "
        printf "%03d" $fourth
        echo -en " \033[48;5;$(echo $fifth)m \033[0m\033[38;5;$(echo $fifth)m█ "
        printf "%03d" $fifth
        echo -en " \033[48;5;$(echo $sixth)m \033[0m\033[38;5;$(echo $sixth)m█ "
        printf "%03d" $sixth
        if [ $seventh -lt 256 ]; then
            echo -en " \033[48;5;$(echo $seventh)m \033[0m\033[38;5;$(echo $seventh)m█ "
            printf "%03d" $seventh
        fi

        local iter=$(($iter+1))
        printf '\r\n'
    done
}

dir_colors ()
{
    typeset -A names
    names[rs]="reset"
    names[no]="global default"
    names[fi]="normal file"
    names[di]="directory"
    names[ln]="symbolic link"
    names[mh]="multi-hardlink"
    names[pi]="named pipe"
    names[so]="socket"
    names[do]="door"
    names[bd]="block device"
    names[cd]="character device"
    names[or]="orphan symlink"
    names[mi]="missing file"
    names[su]="set uid"
    names[sg]="set gid"
    names[st]="sticky directory"
    names[tw]="sticky other writable"
    names[ow]="other writable"
    names[ca]="file with capability"
    names[ex]="executable"

    for i in ${(s.:.)LS_COLORS}
    do
        key=${i%\=*}
        color=${i#*\=}
        name=${names[(e)$key]-$key}
        printf '(\e[%sm%s\e[m) ' $color $name
    done
    echo
}

# }}}
# ssh {{{

ssh_add ()
{
    [ -z "$SSH_AUTH_SOCK" ] && eval $(ssh-agent -s) > /dev/null

    if [ -n "$SSH_AUTH_SOCK" ]
    then
        _SSH_ADD_HOST=$(hostname)
        _SSH_ADD_PASSPHRASE_COMP="computers/$_SSH_ADD_HOST/os/linux/$USER/ssh/passphrase"
        _SSH_ADD_PASSPHRASE_VM="vm/$_SSH_ADD_HOST/os/linux/$USER/ssh/passphrase"
        unset _SSH_ADD_HOST

        if [ -n "${_SSH_ADD_PASSPHRASE:=$(pass "$_SSH_ADD_PASSPHRASE_COMP" 2> /dev/null)}" -o \
            -n "${_SSH_ADD_PASSPHRASE:=$(pass "$_SSH_ADD_PASSPHRASE_VM" 2> /dev/null)}" ]
                then
                    $HOME/.scripts/df/ssh-add.expect "$USER" "$_SSH_ADD_PASSPHRASE"
                else
                    ssh-add
        fi

        unset _SSH_ADD_PASSPHRASE _SSH_ADD_PASSPHRASE_COMP _SSH_ADD_PASSPHRASE_VM
    fi
}

# }}}
# tmux {{{

tx ()
{
    local TMUX_SCRIPT="$HOME/.scripts/df/tmux-new-session.sh"

    DIR="$PWD"
    cd ~
    if [[ -o interactive ]] && [[ ! "$TERM" =~ "screen" ]] && [[ ! "$TERM" =~ "tmux" ]] && [ -z "$TMUX" ]
    then
        if [ -z "$1" ]
        then tmux attach || . "$TMUX_SCRIPT"
        else tmux attach -t "$1" || . "$TMUX_SCRIPT" "$1"
        fi
    fi
    cd -- $DIR
}

txclip ()
{
    tmux set-buffer "$(cat)"
}

# }}}
# bd {{{

bd ()
{
    [ "$#" -eq 0 ] && { cd ..; return; }
    for i in $(seq $1)
    do cd ..
    done
}

# }}}
# lf {{{

cdlf ()
{
    [ "$#" -gt 0 ] && cd "$@"
    [ -n "$id" ] &&
        lf -remote "send $id cd \"$(echo "$PWD" | sed 's/\"/\\\"/g')\""
}

lfcd ()
{
    tmp="$(mktemp)"
    fid="$(mktemp)"
    lf -command '$printf $id > '"$fid"'' -last-dir-path="$tmp" "$@"
    id="$(cat "$fid")"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        rm -f "$tmp"
        [ -d "$dir" -a "$dir" != "$PWD" ] && cd "$dir" || true
    fi
}

# }}}
# remote {{{

remote_si ()
{
    remote "$@" && { echo; separator; shell_info; }
}

# }}}

# vim: ft=zsh: foldmethod=marker:
